% !TeX spellcheck = ru_RU
\chapter{Технологическая часть}
В данном разделе будут рассмотрены средства реализации, а также представлены листинги алгоритма полного перебора и муравьиного алгоритма.

%\section{Средства реализации}
\section{Реализация алгоритмов}
Для данной работы был выбран язык С++ \cite{cpp}. Для данной лабораторной работы требуются инструменты для работы с массивами, матрицами, а также замера процессорного времени. Все перечисленные инструменты присутствуют в выбранном языке программирования.

%\section{Реализация алгоритмов}
В листингах \ref{lst:full_alg}, \ref{lst:full_alg1} представлена реализация алгоритма полного перебора.

\begin{center}
	\begin{lstlisting}[label=lst:full_alg,caption=Алгоритм полного перебора (начало)]
pair<double, vector<int>> full_combinations(vector<vector<double>> &matrix)
{
	vector<int> places(matrix.size());
	iota(begin(places), end(places), 0);
	vector<vector<int>> places_combinations;
	do {
		places_combinations.push_back(places);
	} while (next_permutation(places.begin(), places.end()));
	vector<int> best_way;
	double min_dist = numeric_limits<double>::max();
	for (auto comb : places_combinations)
	{
		comb.push_back(comb[0]);
		double cur_dist = 0;
			\end{lstlisting}
		\clearpage
	\begin{lstlisting}[label=lst:full_alg1,caption=Алгоритм полного перебора (окончание)]
		for (int j = 0; j < matrix.size(); ++j)
		{
			int start_city = comb[j];
			int end_city = comb[j + 1];
			cur_dist += matrix[start_city][end_city];
		}
		if (cur_dist < min_dist)
		{
			min_dist = cur_dist;
			best_way = comb;
		}
	}
	return pair<double, vector<int>>(min_dist, best_way);
}
	\end{lstlisting}
\end{center}


В листингах \ref{lst:ant}, \ref{lst:ant1} представлена реализация муравьиного алгоритма.

\begin{center}
	\begin{lstlisting}[label=lst:ant,caption=Муравьиный алгоритм (начало)]
pair<double, vector<int>> ant_alg(vector<vector<double>> &matrix, double alpha, double beta, double ro, int days)
{
	int places = matrix.size();
	double q = calc_q(matrix, places);
	vector<int> best_way;
	double min_dist = numeric_limits<double>::max();
	vector<vector<double>> pheromones = calc_pheromones(places);
	vector<vector<double>> visibility = calc_visibility(matrix, places);
	int ants = places;
	for (int day = 0; day < days; ++day)
	{
		vector<int> route(places);
		iota(begin(route), end(route), 0);
		vector<vector<int>> visited = calc_visited_places(route, ants);
		for (int ant = 0; ant < ants; ++ant)
		{
		\end{lstlisting}
	\clearpage
\begin{lstlisting}[label=lst:ant1,caption=Муравьиный алгоритм (окончание)]
			while (visited[ant].size() != ants)
			{
				vector<double> pk = find_ways(pheromones, visibility, visited, places, ant, alpha, beta);
				int chosen_place = choose_next_place_by_possibility(pk);
				visited[ant].push_back(chosen_place - 1);
			}
			visited[ant].push_back(visited[ant][0]);
			double cur_length = calc_length(matrix, visited[ant]);
			
			if (cur_length < min_dist)
			{
				min_dist = cur_length;
				best_way = visited[ant];
			}
		}
		pheromones = update_pheromones(matrix, places, visited, pheromones, q, ro);
	}
	return pair<double, vector<int>>(min_dist, best_way);
}
	\end{lstlisting}
\end{center}

В листингах \ref{lst:start} -- \ref{lst:end} представлены реализации вспомогательных функций для муравьиного алгоритма.

\begin{center}
	\begin{lstlisting}[label=lst:start,caption=Алгоритм нахождения массива вероятностей переходов (начало)]
vector<double> find_ways(vector<vector<double>>& pheromones, vector<vector<double>>& visibility, vector<vector<int>>& visited, int places, int ant, double alpha, double beta){
	vector<double> pk(places, 0);
	for (int place = 0; place < places; ++place)
	{
		if (find(visited[ant].begin(), visited[ant].end(), place) == visited[ant].end())
		{
			int ant_place = visited[ant][visited[ant].size() - 1];
			pk[place] = pow(pheromones[ant_place][place], alpha) * \
			pow(visibility[ant_place][place], beta);
		}
	\end{lstlisting}
\clearpage
\begin{lstlisting}[caption=Алгоритм нахождения массива вероятностей переходов (окончание)]
		else
		pk[place] = 0;
	}
	double sum_pk = summ(pk);
	for (int place = 0; place < places; ++place)
	pk[place] /= sum_pk;
	return pk;
}
	\end{lstlisting}
\end{center}

\begin{center}
	\begin{lstlisting}[label=listing_pher,caption=алгоритм обновления матрицы феромонов]
vector<vector<double>> update_pheromones(vector<vector<double>>& matrix, int places, vector<vector<int>>& visited, vector<vector<double>> pheromones, double q, double ro)
{
	int ants = places;
	for (int i = 0; i < places; ++i)
	for (int j = 0; j < places; ++j)
	{
		double delta = 0;
		for (int ant = 0; ant < ants; ++ant)
		{
			double len = calc_length(matrix, visited[ant]);
			delta += q / len;
		}
		pheromones[i][j] *= (1 - ro);
		pheromones[i][j] += delta;
		if (pheromones[i][j] < MIN_PHEROMONE)
		pheromones[i][j] = MIN_PHEROMONE;
	}
	return pheromones;
}
	\end{lstlisting}
\end{center}

\clearpage

\begin{center}
	\begin{lstlisting}[label=lst:end,caption=Алгоритм выбора следующего города]
int choose_next_place_by_possibility(vector<double> &pk)
{
	double possibility = (((double)rand() + 1) / (RAND_MAX));
	double choice = 1e-6;
	int chosen_place = 0;
	
	while (choice < possibility && chosen_place < pk.size())
	{
		choice += pk[chosen_place];
		++chosen_place;
	}
	if (chosen_place == 0)
	cout << 1;
	return chosen_place;
}
	\end{lstlisting}
\end{center}

\section{Функциональные тесты}

Применена методология черного ящика. В таблице \ref{tests} представлены тесты для алгоритмов нахождения гамельтонова пути. 
Все тесты были пройдены успешно.

\begin{table}[h!]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright,singlelinecheck=off}
			\caption{Функциональные тесты}
			\label{tests}
			\begin{tabular}{|c|c|c|}
				\hline
				Матрица смежности & Ожидаемый результат & Результат программы \\
				\hline
				$ \begin{pmatrix}
					0 &  4 &  2 &  1 & 7 \\
					4 &  0 &  3 &  7 & 2 \\
					2 &  3 &  0 & 10 & 3 \\
					1 &  7 & 10 &  0 & 9 \\
					7 &  2 &  3 &  9 & 0
				\end{pmatrix}$ &
				15, [0, 2, 4, 1, 3, 0] &
				15, [0, 2, 4, 1, 3, 0] \\
				\hline			
				$ \begin{pmatrix}
					0 & 1 & 2 \\
					1 & 0 & 1 \\
					2 & 1 & 0	
				\end{pmatrix}$ &
				4, [0, 1, 2, 0] &
				4, [0, 1, 2, 0] \\
				\hline			
				$ \begin{pmatrix}
					0 & 15 & 19 & 20 \\
					15 &  0 & 12 & 13 \\
					19 & 12 &  0 & 17 \\
					20 & 13 & 17 &  0
				\end{pmatrix}$ &
				64, [0, 1, 2, 3, 0] &
				64, [0, 1, 2, 3, 0] \\
				\hline
			\end{tabular}
		\end{threeparttable}	
	\end{center}
\end{table}

\section*{Вывод}
В данном разделе была приведена информация о выбранных средствах для разработки алгоритмов. 
Для реализации алгоритмов был выбран язык C++.
Были представлены листинги и функциональные тесты для каждого из алгоритмов поиска кратчайшего пути.