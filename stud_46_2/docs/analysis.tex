% !TeX spellcheck = ru_RU
\chapter{Аналитическая часть}

В данном разделе разобраны классический алгоритм умножения матриц, алгоритм Винограда, а также его оптимизация.


\section{Матрица}
\textbf{Матрицей} \cite{matrix} называется прямоугольная таблица чисел, содержащая m строк одинаковой длины (или n столбцов одинаковой длины). Матрица записывается в виде:
\begin{equation}
	A_{m \times n} = 
	\begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1n}\\
		a_{21} & a_{22} & \ldots & a_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{m1} & a_{m2} & \ldots & a_{mn}
	\end{pmatrix}.
\end{equation}

Числа $a_{ij}$, составляющие матрицу, называются ее элементами. 

Можно выделить следующие операции над матрицами:
\begin{enumerate}
	\item сложение матриц одинакового размера;
	\item умножение матрицы на число;
	\item умножение матрицы на матрицу. 
\end{enumerate}

Умножение матрицы на матрицу возможно, если количество столбцов первой матрицы равно количеству строк второй матрицы. В итоговой матрице количество строк будет, как у первой матрицы, а столбцов --- как у второй.

\section{Классический алгоритм}
Пусть даны две матрицы:
\begin{equation}
	A_{m \times p} = 
	\begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1p}\\
		a_{21} & a_{22} & \ldots & a_{2p}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{m1} & a_{m2} & \ldots & a_{mp}
	\end{pmatrix} 
	B_{p \times n} = 
	\begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1n}\\
		b_{21} & b_{22} & \ldots & b_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{p1} & b_{p2} & \ldots & b_{pn}
	\end{pmatrix}.
\end{equation}
Произведением матрицы A на матрицу B называется матрица:
\begin{equation}
	\label{eq:C}
	C_{m \times n} = 
	\begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1n}\\
		c_{21} & c_{22} & \ldots & c_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{m1} & c_{m2} & \ldots & c_{mn}
	\end{pmatrix},
\end{equation}
где 
\begin{equation}
	\label{eq:M}
	c_{ij} =
	\sum_{r=1}^{p} a_{ir}b_{rj} \quad (i=\overline{1,m}; j=\overline{1,n})
\end{equation}

Классический алгоритм реализует формулу (\ref{eq:C}).

\section{Алгоритм Винограда}

\textbf{Алгоритм Винограда} \cite{win_mat} --- алгоритм умножения матриц, основанный на предвычислении значений для ускорения операции матричного умножения.

Рассмотрим два вектора $U = (u_1, u_2, u_3, u_4)$ и $V = (v_1, v_2, v_3, v_4)$.\newline
Cкалярное произведение $U \cdot V^T$ равно:
\begin{equation}
U \cdot V^T = u_1v_1 + u_2v_2 + u_3v_3 + u_4v_4.
\end{equation}
Это уравнение эквивалентно:
\begin{equation}
	\label{for:new}
	U \cdot V^T = (u_1 + v_2)(u_2 + v_1) + (u_3 + v_4)(u_4 + v_3) - u_1u_2 - u_3u_4 - v_1v_2 - v_3v_4.
\end{equation}
Произведения простых сомножителей (последние четыре в правой части равенства) можно вычислить заранее и запомнить для каждой строки первой матрицы и каждого столбца второй матрицы. 
За счет этого можно добиться прироста производительности: для вычисления одного элемента итоговой матрицы (произведения) потребуется выполнить два умножения и пять сложений, а затем прибавить к результату заранее запомненные для данной строки первой матрицы и столбца второй матрицы значения. 
Операция сложения выполняется быстрее операции умножения, следовательно, на практике данный алгоритм должен работать быстрее.

Следует учитывать, что в случае нечетного размера матрицы требуется дополнительно добавить произведения крайних элементов соответствующих строк и столбцов.

\section{Оптимизация алгоритма Винограда}
В программной реализации описанного выше алгоритма Винограда можно использовать следующие оптимизации:
\begin{enumerate}
	\item заменить операцию $x = x + k$ на $x += k$;
	\item заменить умножение на 2 на побитовый сдвиг; 
	\item предвычислять некоторые слагаемые из алгоритма.
\end{enumerate}

\section*{Вывод}
В данном разделе были рассмотрены алгоритмы умножения матриц --- классический, алгоритм Винограда и его оптимизация.