% !TeX spellcheck = ru_RU
\chapter{Исследовательская часть}

	Демонстрация работы программы приведена на рисунке (\ref{img:example}).
\img{1}{example}{Пример работы программы для вычисления произведения матриц тремя алгоритмами}

\section{Технические характеристики}

Ниже приведены технические характеристики устройства, на котором было проведено измерение времени работы ПО:

\begin{itemize}
	\item операционная система Windows 10 Домашняя Версия 21H1 \cite{windows} x86\_64;
	\item оперативная память 8 Гб 2133 МГц;
	\item процессор Intel Core i5-8300H с тактовой частотой 2.30 ГГц \cite{intel}.
\end{itemize}

\section{Время выполнения реализаций алгоритмов}

Для замеров времени использовалась функция замера процессорного времени process\_time из библиотеки time на Python. Функция возвращает процессорное время типа float \cite{time}.

Функция используется дважды --- в начале и в конце замера времени, затем значения начальное значение вычитается из конечного.

Замеры проводились для квадратных матриц размерами {200, 300,...,1000} для четной размерности и размерами {201, 301,...,1001} для нечетной размерности.
Матрицы заполнялись случайными числами.

В таблицах \ref{tbl:even} -- \ref{tbl:odd} представлены замеры времени работы для каждого из алгоритмов.


\begin{table}[h]
	\centering
	\caption{Результаты замеров времени работы реализаций алгоритмов на матрицах четной размерности (в мс)}
	\label{tbl:even}
	\csvloop{
		file=csv/even.csv,
		head to column names,
		tabular={|c|
			S[table-format=6.4]|
			S[table-format=6.4]|
			S[table-format=6.4]|},
		table head= \hline{Размерность} & {Классический алг.} & {Алг. Винограда}& {Опт. aлг. Винограда} \\\hline,
		command=  \len & \std & \win & \wino ,
		table foot=\hline}
\end{table}

\begin{table}[h]
	\centering
	\caption{Результаты замеров времени работы реализаций алгоритмов на матрицах нечетной размерности (в мс)}
	\label{tbl:odd}
	\csvloop{
		file=csv/odd.csv,
		head to column names,
		tabular={|c|
			S[table-format=6.4]|
			S[table-format=6.4]|
			S[table-format=6.4]|},
		table head= \hline{Размерность} & {Классический алг.} & {Алг. Винограда}& {Опт. aлг. Винограда} \\\hline,
		command=  \len & \std & \win & \wino ,
		table foot=\hline}
\end{table}
\clearpage
На рисунках \ref{img:even} -- \ref{img:odd} приведены графические результаты замеров.

\img{0.6}{even}{Результаты замеров времени работы реализаций алгоритмов на матрицах четной размерности}
\img{0.6}{odd}{Результаты замеров времени работы реализаций алгоритмов на матрицах нечетной размерности}
\clearpage


Из полученных результатов можно сделать вывод, что классический алгоритм работает быстрее алгоритма Винограда (на четных и нечетных размерностях матриц), однако уступает оптимизированному алгоритму Винограда.

\section*{Вывод}

В результате экспериментов было выявлено, что реализация классического алгоритма умножения матриц работает быстрее реализации алгоритма Винограда (на четных и нечетных размерностях матриц), однако уступает оптимизированной реализации алгоритма Винограда. Для квадратных матриц размерностью $1000\times1000$ реализации дают следующие результаты:
\begin{itemize}
	\item классический алгоритм --- 123,4 с;
	\item алгоритм Винограда --- 145,2 с;
	\item оптимизированный алгоритм Винограда --- 118,0 с.
\end{itemize}

Таким образом, использование оптимизированного алгоритма Винограда является более приоритетным при необходимости ускорить выполнение произведения матриц. 
Однако следует учитывать, что данный алгоритм влечет увеличение затрат памяти для хранение дополнительных массивов.



